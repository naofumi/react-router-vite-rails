# React-Router-Vite-Rails

This is an example web application proposing a way to integrate React Router Framework/SPA mode and Ruby on Rails.

Consider using this if you wish to easily create a better React SPA integrated with Ruby on Rails.

[Jump to how to build it](#how-it-is-built)

## The problem

Historically,
integrating React with Ruby on Rails was done by creating a dedicated Rails route and ERB file as the bootstrap file
(the first HTML file that the browser loads).

You would use `javascript_include_tag` (jsbundling or sprockets)
or `javascript_pack_tag` (webpacker) to load the JavaScript bundle that contains your React application.
If you wish to use Vite,
you might use [Vite Rails](https://github.com/ElMassimo/vite_ruby/tree/main/vite_rails)
and then use  the `vite_javascript_tag`.

However, the traditional approach treats React as a library.
You are responsible for installing the client-side router, implementing code-splitting, avoiding fetch waterfalls, etc.
Although this approach may have been adequate in the past, the React team has recommended against it and suggested that [even for SPAs, developers should use a framework](https://react.dev/blog/2025/02/14/sunsetting-create-react-app).

With this in mind, I propose a solution that allows you to easily integrate an SPA framework with Ruby on Rails.

## The proposal

The current proposal uses React Router version 7 in SPA/Framework mode.

* Instead of creating a bootstrap file (the HTML file that is initially loaded by the browser) in ERB, we use the one that React Router builds in SPA mode (using SSG).
* We send the static bootstrap file through Rails controllers instead of serving it in the `public` directory. This allows us to set caching headers separately and manage cookies efficiently, simplifying authentication and CSRF protection.

### Compared to the traditional method

* Compared to the traditional approach where React is treated as a library, an SPA framework will integrate a client-side routing library.
* It will also give you automatic code-splitting together with data-fetching parallelization and other benefits.

Putting it simply, it should make it easier to create a better SPA.

### Compared to hosting static files on a separate server

* Compared to hosting static files generated by an SPA framework on a separate server, the current approach will let you share the same host and use the same cookies. This makes it easier to manage authentication, CSRF protection, etc.
* With the current approach, there is no need to worry about cross-site requests and CORS.

### Compared to hosting on a Next.js SSR server

* Compared to hosting on a Next.js SSR server, the current approach offers simpler deployment and significantly less expensive hosting.
* Hosting a separate Next.js SSR server will typically require you to re-implement authentication inside Next.js. The current approach can simply use Rails' authentication as is.
* With the current approach, cross-site requests and CORS will no longer be a concern.

Note that you can use Next.js as an SPA
and [use static export](https://nextjs.org/docs/app/building-your-application/upgrading/single-page-applications#static-export-optional).
This will also allow you
to host static files in the Ruby on Rails `public` folder although there are difficulties with dynamic routes. 

## Building the Integration

I have heavily added comments to each file. Please look through these to see how the application is configured.

The step-by-step setup is as follows.

### Install Ruby on Rails

Just run `rails new` to set up the Ruby on Rails server.
A no-build setup will suffice since Rails is not responsible for building the React application.
If you want, you can use jsbundling for additional JavaScript.
Note that any build using jsbundling will be completely independent of the React app.

```shell
rails new [react-router-vite-rails]
```

\[react-router-vite-rails] is the name of the project.

Prepare a route and a controller action to serve the bootstrap HTML template. View the following files in the current directory for guidance.

* `config/routes.rb`
* `app/controllers/react_controller.rb` 

Install the dependencies and start the server.

```shell
cd [react-router-vite-rails]
bundle install
bin/rails s
```

### Install React Router v7

Use the React Router installer. From the root directory of your Rails application, run the following command.

```shell
npx create-react-router@latest [frontend-react-router]
```

\[frontend-react-router] is the name of the directory in which the React Router app will be installed.

Configure the following files to run in SPA mode.
This will set up the development server proxy, and move files to Rails' `public` directory on build.
Also, set up the Ruby rake tasks for running the development server and building assets.
The comments in the following files inside the current repository should guide you.

* `frontend-react-router/react-router.config.ts`
* `frontend-react-router/vite.config.ts`
* `lib/tasks/react_router.rake`

### Run React Router development server

From the root directory, start the React app in developer mode.

```shell
bin/rails react_router:dev
```

Visit your app from the browser using the URL provided in the command line (typically `http://localhost:5173`).

### Preview the React Router build

From the root directory, build the React app.

```shell
bin/rails react_router:build
```

Visit your app from the browser using the Ruby on Rails development server URL (typically `http://localhost:3000`).


## Notable features of the example application

### Artificial delay for all server routes

The example application simulates a slow server by adding a 2-second delay to all server routes.
This gives us a more realistic experience similar to what users might see in the real world.
Note that routes that don't need server connections will be instantaneous.

Any fast website will have a good UI/UX, even with ancient technology, and we need a slower one to demonstrate the benefits of using an SPA framework.

### Authentication

Running React as a static asset on a Ruby on Rails application makes authentication simple. To illustrate this,
I have created a simple session-based authentication system in Rails and have used it from the React application.

Note that the ERB and the React pages will share authentication.
This makes it particularly easy to mix React and ERB pages in the same application 
if you are gradually transitioning from a React-based site to Hotwire, for example.

### CSRF protection

Ruby on Rails provides robust CSRF protection using tokens.
This is particularly important when using session cookies for authentication.

The example application uses the [Cookie-to-header token](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token) approach.
The server sends the CSRF token in a cookie, which can be added to the header of any non-GET request.

Note that because we serve the bootstrap HTML template from a controller action,
the React application is guaranteed to have access to the CSRF token from the first load onwards.
This is convenient when the first page contains a form.

### Cache Control

The bootstrap HTML template is served from a Rails controller action.
As a result, the default Cache-Control header is set to the same value as other ERB files â€“ `Cache-Control: max-age=0, private, must-revalidate`.
On the other hand, assets are served from the `public` folder and have `Cache-Control: public, max-age=172800`.

This ensures that assets use the browser cache effectively, whereas the HTML template is always fresh and users get the most recent version of the app.

### Deployment

The React Router build step is integrated into the `bin/rails assets:precompile` task.
Artifacts are stored inside the Ruby on Rails `public` folder.
Note that we don't use Propshaft for the React Router build, and therefore artifacts are not saved into `app/assets/builds`.

Your Dockerfile and CI setup can stay the same with the exception that you will need to install Node.js.
If you want to learn how to do this, creating a new rails app configured with jsbundling is a great way
to learn how to write a good Dockerfile that installs Node.js.
