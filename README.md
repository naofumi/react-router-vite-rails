# React-Router-Vite-Rails

This is an example web application that proposes a way to integrate React Router Framework/SPA mode with Ruby on Rails.

Consider using the methods in this example
to explore a simple way to create a better React SPA – Rails integration.

- [Jump to read how to build it](#how-it-is-built)
- [See this example app deployed using Kamal](https://rrrails.castle104.com)

## The problem

Historically,
integrating React with Ruby on Rails was done by creating a dedicated Rails route from which you served a static ERB file as the bootstrap file
(the first HTML file that the browser loads).

Inside this ERB file, you would typically use `javascript_include_tag` ([jsbundling](https://github.com/rails/jsbundling-rails) or [sprockets](https://github.com/rails/sprockets))
or `javascript_pack_tag` ([webpacker](https://github.com/rails/webpacker)) to load the JavaScript bundle that contained your React application.
If you wished to use Vite,
you might use [Vite Rails](https://github.com/ElMassimo/vite_ruby/tree/main/vite_rails)
and then use the corresponding `vite_javascript_tag` in exactly the same way.

However, this traditional approach treats React as a library.
You are responsible for installing the client-side router,
implementing code-splitting, avoiding fetch waterfalls, etc.,
all of which have significant implications for performance.
Although this approach may have been adequate in the past,
the React team has recommended against it and suggested that [even if you are only interested in a SPA,
developers should use a framework](https://react.dev/blog/2025/02/14/sunsetting-create-react-app).

With this in mind, I propose a simple solution that allows you to integrate an SPA framework with Ruby on Rails.

## The proposal

The current proposal uses React Router version 7 in SPA/Framework mode.

* Instead of creating a bootstrap file (the HTML file that is initially loaded by the browser) in ERB, we use the one that React Router builds in SPA mode (using SSG).
* We send this static bootstrap file to the browser through Rails controllers instead of serving it in the `public` directory. This allows us to set caching headers separately and manage cookies efficiently, simplifying authentication and CSRF protection.

### Compared to the traditional method

* Compared to the traditional approach where React is treated as a library, an SPA framework will integrate a client-side routing library.
* It will also give you automatic code-splitting together with data-fetching parallelization and other benefits that are important for performance and UX.

Putting it simply, the current method should make it easier to create a better SPA.

### Compared to hosting static files on a separate server

* Compared to hosting static files generated by an SPA framework on a separate server, the current approach will let you share the same host and use the same cookies. This makes it easier to manage authentication, CSRF protection, etc.
* With the current approach, there is no need to worry about cross-site requests and CORS.

### Compared to hosting on a Next.js SSR server

* Compared to hosting on a Next.js SSR server, the current approach offers simpler deployment and significantly less expensive hosting.
* Hosting a separate Next.js SSR server will typically require you to re-implement authentication inside Next.js. The current approach can simply use Rails' authentication as is.
* With the current approach, cross-site requests and CORS will no longer be a concern.

Note that you can use Next.js [with static exports](https://nextjs.org/docs/app/building-your-application/upgrading/single-page-applications#static-export-optional)
to generate files that can be statically hosted as an SPA.
You could put these on a Ruby on Rails `public` folder to achieve simplicity that is similar to the current approach.
However, Next.js static exports have difficulties, particularly with dynamic routes,
which make it less straightforward than React Router v7 in SPA mode.
Hence, my choice of React Router v7 for this example.

## Building the Integration

I have heavily added comments to each file in this repository.
Please read these to understand how the application is configured.

The step-by-step setup is as follows.

### Install Ruby on Rails

Just run `rails new` to set up the Ruby on Rails server.
The default, no-build setup will suffice since Rails is not responsible for building the React Router application.
If you want, you can use [jsbundling](https://github.com/rails/jsbundling-rails) for additional JavaScript.
Note that the React Router app will be completely independent of jsbundling.

```shell
rails new [react-router-vite-rails]
```

\[react-router-vite-rails] is the name of the project.

Prepare a route and a controller action to serve the bootstrap HTML template.
View the comments in the following files for guidance.

* `config/routes.rb`
* `app/controllers/react_controller.rb` 

Install the dependencies and start the server.

```shell
cd [react-router-vite-rails]
bundle install
bin/rails s
```

### Install React Router v7

Use the React Router installer. From the root directory of your Rails application, run the following command.

```shell
npx create-react-router@latest [frontend-react-router]
```

\[frontend-react-router] is the name of the directory in which the React Router app will be installed.

Configure the following files to run in SPA mode.
This will set up the development server proxy, and move files to Rails' `public` directory on build.
You will additionally need to set up the Ruby rake tasks for running the development server and building assets.
The comments in the following files inside the current repository should guide you.

* `frontend-react-router/react-router.config.ts`
* `frontend-react-router/vite.config.ts`
* `lib/tasks/react_router.rake`

### Run React Router development server

From the root directory, start the React app in developer mode.

```shell
bin/rails react_router:dev
```

Visit your app from the browser using the URL provided in the command line (typically `http://localhost:5173`).

### Preview the React Router build

From the root directory, build the React app.

```shell
bin/rails react_router:build
```

Visit your app from the browser using the Ruby on Rails development server URL (typically `http://localhost:3000`).


## Notable features of the example application

### Artificial delay for all server routes

The example application simulates a slow server by adding a 2-second delay to all server routes.
This gives us a more realistic experience similar to what users might see in the real world.
Note that routes that don't need server connections will be instantaneous.

A fast server and a good internet connection will mask any deficiencies of a poorly built SPA.
To understand the benefits of using an SPA framework, I believe that you need to simulate real-world conditions with a slower network.

### Authentication

Running React as a static asset on a Ruby on Rails application makes it possible to share cookies,
and this greatly simplifies authentication.
To illustrate this,
I have created a simple session-based authentication system in Rails and have used it from the React application.

Note that the ERB and the React pages will share authentication.
This makes it particularly easy to mix React and ERB pages in the same application. 
This helps a lot if you are gradually transitioning from a React-based site to Hotwire, for example.

### CSRF protection

Ruby on Rails provides robust CSRF protection using tokens.
This is particularly important when using session cookies for authentication.

The example application uses the [Cookie-to-header token](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token) approach.
The server sends the CSRF token in a cookie, which can be added to the header of any non-GET request.

Note that because we serve the bootstrap HTML template from a controller action,
the React application is guaranteed to have access to the CSRF token from the first load onwards.
This is convenient when the first loaded page contains a form
and needs a valid CSRF token from the onset to allow immediate submission.

### Cache Control

The bootstrap HTML template is served from a Rails controller action.
As a result, the default Cache-Control header is set to the same value as other ERB files – `Cache-Control: max-age=0, private, must-revalidate`.
On the other hand, assets are served from the `public` folder and have `Cache-Control: public, max-age=172800`.

This ensures that assets served from `public` use the browser cache effectively,
whereas the HTML template served from the Rails controller is always fresh and always provides the most recent version of the app.

Note that assets served from the `public` folder will have hash-digests to bust caching.
However, since the bootstrap HTML template is the first file to be loaded,
it always has to have the same URL, and this precludes the use of hash-digests on this one.
Therefore, we need separate caching configurations for each.

### Deployment

NPM installation and the React Router build step are integrated into the `bin/rails assets:precompile` task.
Artifacts are stored inside the Ruby on Rails `public` folder.

Since we tap into the asset pipeline commands,
your Dockerfile and CI setup can stay the same with the exception that you may need to install Node.js.
See the `Dockerfile` for an example of this.
